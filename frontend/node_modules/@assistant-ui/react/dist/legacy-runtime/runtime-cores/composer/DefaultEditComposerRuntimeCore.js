import { getThreadMessageText } from "../../../utils/getThreadMessageText.js";
import { BaseComposerRuntimeCore } from "./BaseComposerRuntimeCore.js";
export class DefaultEditComposerRuntimeCore extends BaseComposerRuntimeCore {
    runtime;
    endEditCallback;
    get canCancel() {
        return true;
    }
    getAttachmentAdapter() {
        return this.runtime.adapters?.attachments;
    }
    getDictationAdapter() {
        return this.runtime.adapters?.dictation;
    }
    _nonTextParts;
    _previousText;
    _parentId;
    _sourceId;
    constructor(runtime, endEditCallback, { parentId, message }) {
        super();
        this.runtime = runtime;
        this.endEditCallback = endEditCallback;
        this._parentId = parentId;
        this._sourceId = message.id;
        this._previousText = getThreadMessageText(message);
        this.setText(this._previousText);
        this.setRole(message.role);
        this.setAttachments(message.attachments ?? []);
        this._nonTextParts = message.content.filter((part) => part.type !== "text");
        // Use the runConfig from the regular (non-edit) composer as the initial runConfig for the edit composer
        this.setRunConfig({ ...runtime.composer.runConfig });
    }
    async handleSend(message) {
        const text = getThreadMessageText(message);
        if (text !== this._previousText) {
            this.runtime.append({
                ...message,
                content: [...message.content, ...this._nonTextParts],
                parentId: this._parentId,
                sourceId: this._sourceId,
            });
        }
        this.handleCancel();
    }
    handleCancel() {
        this.endEditCallback();
        this._notifySubscribers();
    }
}
//# sourceMappingURL=DefaultEditComposerRuntimeCore.js.map